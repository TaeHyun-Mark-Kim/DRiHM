let test2=StringMap2.(add "one" [1;1] empty);;
 :-val test : int list list StringMap2.t = <abstr>

let test = StringMap2.(add "one" [[0];[1]] empty);;
  :-val test2 : int list StringMap2.t = <abstr>


  let map3 = StringMap.merge (fun k xo yo -> match xo,yo with
      | Some x, Some y -> Some (x, y)
      | _ -> None
    ) test test2;;
   :-val map3 : (int list list * int list) StringMap2.t = <abstr>


   StringMap.bindings map3;;
- : (string * (int list list * int list)) list =
[("one", ([[0]; [1]], [1; 1]))]

  StringMap.find "one" map3;;
- : int list list * int list = ([[0]; [1]], [1; 1])

---------------------------------
let add_bind map (name, ty, ret) = StringMap.add name {
typ = ret;
fname = name;
formals =
  (let rec create_ty_list = (function
    [] -> []
    | hd::tl -> (hd, "x", Noexpr)::(create_ty_list tl))
  in create_ty_list ty);
locals = []; body = [] } map


--------
let symbols = List.fold_left (fun m (ty, name, _) -> StringMap.add name ty m)
              StringMap.empty (globals @ func.formals @ func.locals )
in

(* Return a variable from our local symbol table *)
let type_of_identifier s =
  try StringMap.find s symbols
  with Not_found -> raise (Failure ("undeclared identifier " ^ s))
in
